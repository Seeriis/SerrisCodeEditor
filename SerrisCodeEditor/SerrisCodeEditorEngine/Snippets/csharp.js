define("ace/snippets/csharp",["require","exports","module"],function(e,t,n){"use strict";t.snippetText='# cs.snippets\n# ===========\n# \n# Standard C-Sharp snippets for snipmate.\n#\n# Largely ported over from Visual Studio 2010 snippets plus\n# a few snippets from Resharper plus a few widely known snippets.\n#\n# Most snippets on elements (i.e. classes, properties) \n# follow suffix conventions. The order of suffixes to a snippet\n# is fixed.\n#\n# Snippet Suffix Order\n# --------------------\n# 1. Access Modifiers\n# 2. Class Modifiers\n#\n# Access Modifier Suffix Table\n# ----------------------------\n# + = public\n# & = internal\n# | = protected\n# - = private\n#\n# Example: `cls&` expands to `internal class $1`.\n# Access modifiers might be doubled to indicate\n# different modifiers for get/set on properties.\n# Example: `pb+-` expands to `public bool $1 { get; private set; }`\n#\n# Class Modifier Table\n# --------------------\n# ^ = static\n# % = abstract\n#\n# Example: `cls|%` expands to `protected abstract class $1`\n#\n# On method and property snippets, you can directly set\n# one of the common types int, string and bool, if desired,\n# just by appending the type modifier.\n#\n# Type Modifier Table\n# -------------------\n# i = integer\n# s = string\n# b = bool\n#\n# Example: `pi+&` expands to `public int $1 { get; internal set; }`\n#\n# I\'ll most propably add more stuff in here like\n# * List/Array constructio\n# * Mostly used generics\n# * Linq\n# * Funcs, Actions, Predicates\n# * Lambda\n# * Events\n#\n# Feedback is welcome!\n# \n# entry point\nsnippet sim\n	public static int Main(string[] args) {\n		${1}\n		return 0;\n	} \nsnippet simc\n	public class Application {\n		public static int Main(string[] args) {\n			${1}\n			return 0;\n		}\n	}\n# if condition\nsnippet if\n	if (${1}) {\n		${2}\n	} \nsnippet el\n	else {\n		${1}\n	} \nsnippet ifs\n	if (${1}) \n		${2}\n# ternary conditional\nsnippet t\n	${1} ? ${2} : ${3}\nsnippet ?\n	${1} ? ${2} : ${3}\n# do while loop\nsnippet do\n	do {\n		${2}\n	} while (${1});\n# while loop\nsnippet wh\n	while (${1}) {\n		${2}\n	}\n# for loop\nsnippet for\n	for (int ${1:i} = 0; $1 < ${2:count}; $1${3:++}) {\n		${4}\n	}\n# foreach\nsnippet fore\n	foreach (var ${1:entry} in ${2}) {\n		${3}\n	}\nsnippet foreach\n	foreach (var ${1:entry} in ${2}) {\n		${3}\n	}\nsnippet each\n	foreach (var ${1:entry} in ${2}) {\n		${3}\n	}\n# interfaces\nsnippet interface\n	public interface ${1:`Filename()`} {\n		${2}\n	}\nsnippet if+\n	public interface ${1:`Filename()`} {\n		${2}\n	}\n# class bodies\nsnippet class\n	public class ${1:`Filename()`} {\n		${2}\n	}\nsnippet cls\n	${2:public} class ${1:`Filename()`} {\n		${3}\n	}\nsnippet cls+\n	public class ${1:`Filename()`} {\n		${2}\n	}\nsnippet cls+^\n	public static class ${1:`Filename()`} {\n		${2}\n	}\nsnippet cls&\n	internal class ${1:`Filename()`} {\n		${2}\n	}\nsnippet cls&^\n	internal static class ${1:`Filename()`} {\n		${2}\n	}\nsnippet cls|\n	protected class ${1:`Filename()`} {\n		${2}\n	}\nsnippet cls|%\n	protected abstract class ${1:`Filename()`} {\n		${2}\n	}\n# constructor\nsnippet ctor\n	public ${1:`Filename()`}() {\n		${2}\n	}\n# properties - auto properties by default.\n# default type is int with layout get / set.\nsnippet prop\n	${1:public} ${2:int} ${3:} { get; set; }${4}\nsnippet p\n	${1:public} ${2:int} ${3:} { get; set; }${4}\nsnippet p+\n	public ${1:int} ${2:} { get; set; }${3}\nsnippet p+&\n	public ${1:int} ${2:} { get; internal set; }${3}\nsnippet p+|\n	public ${1:int} ${2:} { get; protected set; }${3}\nsnippet p+-\n	public ${1:int} ${2:} { get; private set; }${3}\nsnippet p&\n	internal ${1:int} ${2:} { get; set; }${3}\nsnippet p&|\n	internal ${1:int} ${2:} { get; protected set; }${3}\nsnippet p&-\n	internal ${1:int} ${2:} { get; private set; }${3}\nsnippet p|\n	protected ${1:int} ${2:} { get; set; }${3}\nsnippet p|-\n	protected ${1:int} ${2:} { get; private set; }${3}\nsnippet p-\n	private ${1:int} ${2:} { get; set; }${3}\n# property - bool\nsnippet pi\n	${1:public} int ${2:} { get; set; }${3}\nsnippet pi+\n	public int ${1} { get; set; }${2}\nsnippet pi+&\n	public int ${1} { get; internal set; }${2}\nsnippet pi+|\n	public int ${1} { get; protected set; }${2}\nsnippet pi+-\n	public int ${1} { get; private set; }${2}\nsnippet pi&\n	internal int ${1} { get; set; }${2}\nsnippet pi&|\n	internal int ${1} { get; protected set; }${2}\nsnippet pi&-\n	internal int ${1} { get; private set; }${2}\nsnippet pi|\n	protected int ${1} { get; set; }${2}\nsnippet pi|-\n	protected int ${1} { get; private set; }${2}\nsnippet pi-\n	private int ${1} { get; set; }${2}\n# property - bool\nsnippet pb\n	${1:public} bool ${2:} { get; set; }${3}\nsnippet pb+\n	public bool ${1} { get; set; }${2}\nsnippet pb+&\n	public bool ${1} { get; internal set; }${2}\nsnippet pb+|\n	public bool ${1} { get; protected set; }${2}\nsnippet pb+-\n	public bool ${1} { get; private set; }${2}\nsnippet pb&\n	internal bool ${1} { get; set; }${2}\nsnippet pb&|\n	internal bool ${1} { get; protected set; }${2}\nsnippet pb&-\n	internal bool ${1} { get; private set; }${2}\nsnippet pb|\n	protected bool ${1} { get; set; }${2}\nsnippet pb|-\n	protected bool ${1} { get; private set; }${2}\nsnippet pb-\n	private bool ${1} { get; set; }${2}\n# property - string\nsnippet ps\n	${1:public} string ${2:} { get; set; }${3}\nsnippet ps+\n	public string ${1} { get; set; }${2}\nsnippet ps+&\n	public string ${1} { get; internal set; }${2}\nsnippet ps+|\n	public string ${1} { get; protected set; }${2}\nsnippet ps+-\n	public string ${1} { get; private set; }${2}\nsnippet ps&\n	internal string ${1} { get; set; }${2}\nsnippet ps&|\n	internal string ${1} { get; protected set; }${2}\nsnippet ps&-\n	internal string ${1} { get; private set; }${2}\nsnippet ps|\n	protected string ${1} { get; set; }${2}\nsnippet ps|-\n	protected string ${1} { get; private set; }${2}\nsnippet ps-\n	private string ${1} { get; set; }${2}\n# members - void\nsnippet m\n	${1:public} ${2:void} ${3:}(${4:}) {\n		${5:}\n	}\nsnippet m+\n	public ${1:void} ${2:}(${3:}) {\n		${4:}\n	}\nsnippet m&\n	internal ${1:void} ${2:}(${3:}) {\n		${4:}\n	}\nsnippet m|\n	protected ${1:void} ${2:}(${3:}) {\n		${4:}\n	}\nsnippet m-\n	private ${1:void} ${2:}(${3:}) {\n		${4:}\n	}\n# members - int\nsnippet mi\n	${1:public} int ${2:}(${3:}) {\n		${4:return 0;}\n	}\nsnippet mi+\n	public int ${1:}(${2:}) {\n		${3:return 0;}\n	}\nsnippet mi&\n	internal int ${1:}(${2:}) {\n		${3:return 0;}\n	}\nsnippet mi|\n	protected int ${1:}(${2:}) {\n		${3:return 0;}\n	}\nsnippet mi-\n	private int ${1:}(${2:}) {\n		${3:return 0;}\n	}\n# members - bool\nsnippet mb\n	${1:public} bool ${2:}(${3:}) {\n		${4:return false;}\n	}\nsnippet mb+\n	public bool ${1:}(${2:}) {\n		${3:return false;}\n	}\nsnippet mb&\n	internal bool ${1:}(${2:}) {\n		${3:return false;}\n	}\nsnippet mb|\n	protected bool ${1:}(${2:}) {\n		${3:return false;}\n	}\nsnippet mb-\n	private bool ${1:}(${2:}) {\n		${3:return false;}\n	}\n# members - string\nsnippet ms\n	${1:public} string ${2:}(${3:}) {\n		${4:return "";}\n	}\nsnippet ms+\n	public string ${1:}(${2:}) {\n		${3:return "";}\n	}\nsnippet ms&\n	internal string ${1:}(${2:}) {\n		${3:return "";}\n	}\nsnippet ms|\n	protected string ${1:}(${2:}) {\n		${3:return "";}\n	}\nsnippet ms-\n	private string ${1:}(${2:}) {\n		${3:return "";}\n	}\n# structure\nsnippet struct\n	public struct ${1:`Filename()`} {\n		${2}\n	}\n# enumeration\nsnippet enum\n	public enum ${1} {\n		${2}\n	}\n# preprocessor directives\nsnippet #if\n	#if\n		${1}\n	#endif\n# inline xml documentation\nsnippet ///\n	/// <summary>\n	/// ${1}\n	/// </summary>\nsnippet <p\n	<param name="${1}">${2:$1}</param>${3}\nsnippet <ex\n	<exception cref="${1:System.Exception}">${2}</exception>${3}\nsnippet <r\n	<returns>${1}</returns>{${2}\nsnippet <s\n	<see cref="${1}"/>${2}\nsnippet <rem\n	<remarks>${1}</remarks>${2}\nsnippet <c\n	<code>${1}</code>${2}\n',t.scope="csharp"})